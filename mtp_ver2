#include<iostream>
#include<cmath>
using namespace std;
// define struct and struct function
// the case not considered: if there is one store that needs a lot of goods...

struct Logis{
	int id;
	int x;
	int y;
	int construct_cost;
	int capacity;
};

struct Store{
	int id;
	int x;
	int y;
	int demand;
	int construct_cost;
	int prod_price;
	int man_dist(Logis logis_info);
};

int Store::man_dist(Logis logis_info){
	int dist = abs(x - logis_info.x) + abs(y - logis_info.y);
	return dist;
} 

// some global functions
void data_input(Store* store_info, Logis* logis_info, int store_num, int logis_num);
void assignLogistics(Store* store_info, Logis* logis_info, int** store_logis_pair, int** store_logis_raw_profit, 
					int logis_num, int store_num, int unit_km_cost);
int raw_profit(int man_dist, int prod_price, int unit_km_cost);
void arrangeLogisStorePair(int* raw_profit_array, int* probable_logis_store, int logis_num);
void copyStoreLogisPair(int** store_logis_pair, int* probable_logis_store, int** store_logis_raw_profit, int* raw_profit_array, 
						int logis_num, int store_index);

void profitStore(int** store_logis_net_profit, int** store_logis_raw_profit, Store* store_info, int store_num, int logis_num);
void alterStoreLogisPair(int** store_logis_pair, int** store_logis_net_profit, int store_num, int logis_num);
void logisChosenCnt(int** store_logis_pair, int* logis_index, int* logis_chosen_cnt_arr, int store_num, int logis_num);
void iniConstructArr(int** replenish_plan, bool* construct_logis, bool* construct_store, int store_num, int logis_num);
//void logisStoreChoose(int** store_logis_pair, int** store_logis_net_profit, int logis_index, 
//Logis* logis_info, Store* store_info, int* final_decision, int store_num, int logis_num);
void logisStoreDecide(int** store_logis_pair, int** store_logis_net_profit, int logis_index, Logis* logis_info, 
Store* store_info, int* final_decision, int** replenish_plan, int unit_km_cost, int store_num, int logis_num);
bool check_positive(int remain_goods, int store_index, int logis_index, Store* store_info, Logis* logis_info, 
int unit_km_cost);
void constructLogis(bool* construct_logis, int index);
void constructStore(bool* construct_store, int index);
void alterReplenishPlan(int** replenish_plan, int store_index, int logis_index, Store* store_info);
void printOutput(int construct_logis_cnt, bool* construct_logis, int construct_store_cnt, bool* construct_store, 
int** replenish_plan, int logis_num, int store_num);

int main(){
	int logis_num = 0;
	int store_num = 0;
	int unit_km_cost = 0;
	int logis_mode = 0;
	cin >> logis_num >> store_num >> unit_km_cost >> logis_mode;
	
	Store* store_info = new Store[store_num];
	Logis* logis_info = new Logis[logis_num];
	data_input(store_info, logis_info, store_num, logis_num);
	
	// construct store_logis_pair
	int** store_logis_pair = new int*[store_num];
	int** store_logis_raw_profit = new int*[store_num]; 
	int** store_logis_net_profit = new int*[store_num];
	assignLogistics(store_info, logis_info, store_logis_pair, store_logis_raw_profit, logis_num, store_num, unit_km_cost);
	profitStore(store_logis_net_profit, store_logis_raw_profit, store_info, store_num, logis_num);
	alterStoreLogisPair(store_logis_pair, store_logis_net_profit, store_num, logis_num);
	cout << "the net profit of store pair with logistics center" << endl;
	for(int i = 0; i < store_num; i++){
		for(int j = 0; j < logis_num; j++)
			cout << store_logis_net_profit[i][j] << " ";
		cout << "\n";	
	}
	cout << "the store logis pair (after checking the net profit)" << endl;
	for(int i = 0; i < store_num; i++){
		for(int j = 0; j < logis_num; j++)
			cout << store_logis_pair[i][j] << " ";
		cout << "\n";	
	}
	
	int* logis_chosen_cnt = new int[logis_num];
	int* logis_index = new int[logis_num]; // store the logis to be processed first...
	logisChosenCnt(store_logis_pair, logis_index, logis_chosen_cnt, store_num, logis_num); // logis_index??
	arrangeLogisStorePair(logis_chosen_cnt, logis_index, logis_num); // not originally the function is intended to use!
	
	// final step
	int* final_decision = new int[store_num];
	int construct_logis_cnt = 0;
	int construct_store_cnt = 0;
	bool* construct_logis = new bool[logis_num];
	bool* construct_store = new bool[store_num];
	int** replenish_plan = new int*[store_num];
	
	iniConstructArr(replenish_plan, construct_logis, construct_store, store_num, logis_num);
	for(int i = 0; i < logis_num; i++){
		int curr_logis_index = logis_index[i];
		//logisStoreChoose(store_logis_pair, store_logis_net_profit, curr_logis_index, logis_info, 
						//store_info, final_decision, store_num, logis_num);
		logisStoreDecide(store_logis_pair, store_logis_net_profit, curr_logis_index, logis_info, store_info,
						final_decision, replenish_plan, unit_km_cost, store_num, logis_num);
		if(final_decision[0] != -1){ // the first final decision plan is -1
			construct_logis_cnt += 1;
			// set the store to be constructed! // a function
			constructLogis(construct_logis, curr_logis_index);
			for(int i = 0; i < store_num; i++){
				if(final_decision[i] == -1) 
					break;
				else{
					construct_store_cnt += 1;
					constructStore(construct_store, final_decision[i]);
					//alterReplenishPlan(replenish_plan, final_decision[i], curr_logis_index, store_info);
				} 
			}
		}	
	}
	
	printOutput(construct_logis_cnt, construct_logis, construct_store_cnt, construct_store, 
	replenish_plan, logis_num, store_num);
	
	return 0;
} 

void data_input(Store* store_info, Logis* logis_info, int store_num, int logis_num){
	
	for(int i = 0; i < logis_num; i++)
		cin >> logis_info[i].x >> logis_info[i].y;
		 
	for(int i = 0; i < store_num; i++)
		cin >> store_info[i].x >> store_info[i].y;
	
	for(int i = 0; i < store_num; i++)
		cin >> store_info[i].demand;
	
	
	for(int i = 0; i < store_num; i++)
		cin >> store_info[i].construct_cost;
	
	
	for(int i = 0; i < store_num; i++)
		cin >> store_info[i].prod_price;

	for(int i = 0; i < logis_num; i++)
		cin >> logis_info[i].construct_cost;
	
	for(int i = 0; i < logis_num; i++)
		cin >> logis_info[i].capacity;
	
	// input id;
	for(int i = 0; i < logis_num; i++)
		logis_info[i].id = i;
	
	for(int i = 0; i < store_num; i++)
		store_info[i].id = i;
		
}

void assignLogistics(Store* store_info, Logis* logis_info, int** store_logis_pair, int** store_logis_raw_profit, 
					int logis_num, int store_num, int unit_km_cost){
						
	// initialize store_logis_pair
	for(int i = 0; i < store_num; i++){
		store_logis_pair[i] = new int[logis_num];	
		store_logis_raw_profit[i] = new int[logis_num];
	}
		
	
	for(int i = 0; i < store_num; i++)
		for(int j = 0; j < logis_num; j++){
			store_logis_pair[i][j] = -1;
			store_logis_raw_profit[i][j] = -1;
		} 
	
	for(int i = 0; i < store_num; i++){
		int curr_raw_profit = 0;
		int curr_man_dist = 0;
		int* raw_profit_array = new int[logis_num];
		int* probable_logis_store = new int[logis_num];
		
		for(int j = 0; j < logis_num; j++){ // logistics
			curr_man_dist = store_info[i].man_dist(logis_info[j]);
			//cout << "the current manhattan dist will be " << curr_man_dist << endl;
			raw_profit_array[j] = raw_profit(curr_man_dist, store_info[i].prod_price, unit_km_cost);
			// probable logis paired with the store
			probable_logis_store[j] = logis_info[j].id;
		}
		arrangeLogisStorePair(raw_profit_array, probable_logis_store, logis_num);
		copyStoreLogisPair(store_logis_pair, probable_logis_store, store_logis_raw_profit, raw_profit_array, 
	logis_num, store_info[i].id);
		
		// free the allocated memory
		delete[] raw_profit_array;
		delete[] probable_logis_store;
		
	}
	
	return;
}
int raw_profit(int man_dist, int prod_price, int unit_km_cost){
	// calculate the term (p - c * d_ij) 
	int profit = prod_price - unit_km_cost * man_dist;	
	return profit;
}

// The name of this function might have to be changed
void arrangeLogisStorePair(int* raw_profit_array, int* probable_logis_store, int logis_num){
	
	// implement bubblesort
	for(int i = logis_num - 1; i >= 0; i--)
		for(int j = 0; j <= i - 1; j++){
			if(raw_profit_array[j] > raw_profit_array[j + 1]){
				// swap
				int tmp = raw_profit_array[j + 1];
				int tmp_2 = probable_logis_store[j + 1];
				//cout << " tmp " << tmp << " tmp2 " << endl; 
				
				raw_profit_array[j + 1] = raw_profit_array[j];
				probable_logis_store[j + 1] = probable_logis_store[j];
				//cout << " raw_profit_array[j + 1] " << raw_profit_array[j + 1] << " " << "probable_logis_store[j + 1] " << probable_logis_store[j + 1] << endl;
				raw_profit_array[j] = tmp;
				probable_logis_store[j] = tmp_2;
				//cout << " raw_profit_array[j] " << 	raw_profit_array[j] << " probable_logis_store[j]  " <<probable_logis_store[j] <<endl ;
			}
		} // OK
	
	// reverse
	int* reversed_raw_profit = new int[logis_num];
	int* reversed_probable_logis_store = new int[logis_num];
	
	for(int i = 0; i < logis_num; i++){
		reversed_raw_profit[i] = raw_profit_array[(logis_num - 1) - i] ;
		reversed_probable_logis_store[i] = probable_logis_store[(logis_num - 1) - i];
	}
	
	// copy back
	for(int i = 0; i < logis_num; i++){
		raw_profit_array[i] = reversed_raw_profit[i];
		probable_logis_store[i] = reversed_probable_logis_store[i];
	}
//	cout <<" the probable logis store " << "\n";
//	for(int i = 0; i < logis_num; i++)
//		cout << probable_logis_store[i] << " ";
//	cout << "the probable raw_profit " << "\n";
//	for(int i = 0; i < logis_num; i++)
//		cout << raw_profit_array[i] << " ";
//	cout << endl;
//	
		
	// delete statement
	delete[] reversed_raw_profit;
	delete[] reversed_probable_logis_store;
}

void copyStoreLogisPair(int** store_logis_pair, int* probable_logis_store, int** store_logis_raw_profit, int* raw_profit_array, 
	int logis_num, int store_index){
	
	for(int i = 0; i < logis_num; i++){
		store_logis_pair[store_index][i] = probable_logis_store[i];
		store_logis_raw_profit[store_index][i] = raw_profit_array[i];
		
		//cout << probable_logis_store[i] << " ";
	} 	
}

void profitStore(int** store_logis_net_profit, int** store_logis_raw_profit, Store* store_info, int store_num, int logis_num){
	// initialize store_logis_net_profit
	for(int i = 0; i < store_num; i++)
		//for(int j = 0; j < num_logis; j++)
		store_logis_net_profit[i] = new int[logis_num];
		
	for(int i = 0; i < store_num; i++)
		for(int j = 0; j < logis_num; j++)
		// if in the same row, then the demand and construction cost is the same
			store_logis_net_profit[i][j] = store_logis_raw_profit[i][j] * store_info[i].demand - store_info[i].construct_cost;
				
		
}
void alterStoreLogisPair(int** store_logis_pair, int** store_logis_net_profit, int store_num, int logis_num){
	for(int i = 0; i < store_num; i++)
		for(int j = 0; j < logis_num; j++)
			if(store_logis_net_profit[i][j] <= 0)
				// The store can't be built, for it will cause 0 or negative profit. -> It can't strike the balance!
				store_logis_pair[i][j] = -1; 
	
	return;
}

void logisChosenCnt(int** store_logis_pair, int* logis_index, int* logis_chosen_cnt_arr, int store_num, int logis_num){
	// intialization
	for(int i = 0; i < logis_num; i++)
		logis_index[i] = i;
		
	for(int i = 0; i < logis_num; i++)
		logis_chosen_cnt_arr[i] = 0;
	
	// calculation
	// I only calculate the first row
	for(int i = 0; i < store_num; i++){
		int chosen_logis = store_logis_pair[i][0];
		if(chosen_logis != -1)
			logis_chosen_cnt_arr[chosen_logis] += 1;
	}
}

void iniConstructArr(int** replenish_plan, bool* construct_logis, bool* construct_store, int store_num, int logis_num){
	// initilaiza replenish plan
	for(int i = 0; i < store_num; i++)
		replenish_plan[i] = new int[logis_num];
		
	for(int i = 0; i < store_num; i++)
		for(int j = 0; j < logis_num; j++)
			replenish_plan[i][j] = 0;
	
	// initializa the construct logis
	for(int i = 0; i < logis_num; i++)
		construct_logis[i] = false;
		
	for(int i = 0; i < store_num; i++)
		construct_store[i] = false;
	
}

// This place is currently changed! // 11/24/2021
void logisStoreDecide(int** store_logis_pair, int** store_logis_net_profit, int logis_index, Logis* logis_info, Store* store_info,
int* final_decision, int** replenish_plan, int unit_km_cost, int store_num, int logis_num){
	
	// intialize to be -1
	// when entering the loop once, the array(final_decisionã€tmp_decision) will be initialized
	
	int* tmp_deci_store = new int[store_num]; // probably one logistics center will be paired with all of the store
	int* tmp_deci_good = new int[store_num];
	for(int i = 0; i < store_num; i++){
		final_decision[i] = -1;
		tmp_deci_store[i] = -1;
		tmp_deci_good[i] = -1;
	}
		
	
	int capacity = logis_info[logis_index].capacity;
	int tmp_decision_cnt = -1; // used as index
	int curr_profit = 0;
	// loop thorugh the store_logis_pair array, only loop through the first column
	for(int i = 0; i < store_num; i++){
		if(store_logis_pair[i][0] == logis_index){
			if(capacity - store_info[i].demand >= 0){
				capacity -= store_info[i].demand;
				curr_profit += store_logis_net_profit[i][0];
				tmp_decision_cnt += 1;
				tmp_deci_store[tmp_decision_cnt] = i;
				tmp_deci_good[tmp_decision_cnt] = store_info[i].demand;
			}
			else{
				bool positive = check_positive(capacity, i, logis_index, store_info, logis_info, unit_km_cost);
				cout << "The positiveness?? " << positive;
				if(positive == true){
					tmp_decision_cnt += 1;
					tmp_deci_store[tmp_decision_cnt] = i;
					tmp_deci_good[tmp_decision_cnt] = capacity; // we shouldn;t stuff in the store_info[i].demand
					capacity = 0;
					break;
				}
				else
					break;	
			}
		}
	}
		
	// copy the tmp_decision_into final decision
	// also fill in the replensih plan
	if(curr_profit > logis_info[logis_index].construct_cost){
		for(int i = 0; i < tmp_decision_cnt + 1; i++){
			final_decision[i] = tmp_deci_store[i];
			replenish_plan[final_decision[i]][logis_index] = tmp_deci_good[i];	
		}	
	}
		
	delete[] tmp_deci_store;
	delete[] tmp_deci_good;
	return;
}

bool check_positive(int remain_goods, int store_index, int logis_index, Store* store_info, Logis* logis_info, 
int unit_km_cost){
	// This part has to be checked!
//	cout << "logistics index " << logis_index << endl;
//	cout << " store index " << store_index << endl;
//	cout << "man hattan dist " <<  store_info[store_index].man_dist(logis_info[logis_index]) << endl;
//	cout << "remain goods " << remain_goods;
	
	int result = (store_info[store_index].prod_price - 
	unit_km_cost * store_info[store_index].man_dist(logis_info[logis_index])) * remain_goods - store_info[store_index].construct_cost;
	//cout << "the result will be ..." << result << endl;
	
	if(result > 0)
		return true;
	else
		return false;
} 
void constructLogis(bool* construct_logis, int index){
	construct_logis[index] = true;
}

void constructStore(bool* construct_store, int index){
	construct_store[index] = true;
}

void printOutput(int construct_logis_cnt, bool* construct_logis, int construct_store_cnt, bool* construct_store, 
int** replenish_plan, int logis_num, int store_num){
	
	cout << "...." <<construct_logis_cnt << " ";
	// output - needs to be checked!
	for(int i = 0; i < logis_num; i++){
		int cnt = 0;
		if(construct_logis[i] == true && cnt == construct_logis_cnt - 1){
			cout << i + 1;
			break;
		}
		else{
			if(construct_logis[i] == true){
				cout << i + 1 << " ";
				cnt++;
			}
		}
	}
	cout << endl;
	cout << construct_store_cnt << " ";
	for(int i = 0; i < store_num; i++){
		int cnt = 0;
		if(construct_store[i] == true && cnt == construct_store_cnt - 1){
			cout << i + 1;
			break;
		}
		else{
			if(construct_store[i] == true){
				cout << i + 1 << " ";
				cnt++;
			}		
		}
	}
	cout << endl;
	for(int i = 0; i < store_num; i++){
		for(int j = 0; j < logis_num; j++){
			if(j == logis_num - 1) 
				cout << replenish_plan[i][j];
			else
				cout << replenish_plan[i][j] << " ";
		}
		cout << "\n";	
	} 

}

